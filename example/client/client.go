// It's autogenerated file. It's not recommended to modify it.
package client

import (
	"bytes"
	"encoding/json"
	"fmt"
	"golang.org/x/net/context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

type IBalancer interface {
	Next() (string, error)
}

type Example struct {
	client      *http.Client
	serviceName string
	balancer    IBalancer
}

func NewExample(balancer IBalancer, apiTimeout time.Duration) *Example {
	return &Example{
		client: &http.Client{
			Transport: &http.Transport{
				//DisableCompression: true,
				MaxIdleConnsPerHost: 20,
			},
			Timeout: apiTimeout,
		},
		serviceName: "Example",
		balancer:    balancer,
	}
}

func (api *Example) TestHandler1V1(ctx context.Context, options TestHandler1V1Args) (*TestHandler1V1Res, error) {
	var result TestHandler1V1Res
	err := api.set(ctx, "/test/handler1/v1", options, &result)
	return &result, err
}

func (api *Example) TestHandler1V2(ctx context.Context, options TestHandler1V2Args) (*TestHandler1V2Res, error) {
	var result TestHandler1V2Res
	err := api.set(ctx, "/test/handler1/v2", options, &result)
	return &result, err
}

func (api *Example) TestHandler1V3(ctx context.Context, options TestHandler1V3Request) (*TestHandler1V3Response, error) {
	var result TestHandler1V3Response
	err := api.set(ctx, "/test/handler1/v3", options, &result)
	return &result, err
}

type TestHandler1V1Res struct {
	String string `json:"string"`
	Int    int    `json:"int"`
}

type TestHandler1V1Args struct {
	ReqInt int `json:"req_int"`
	Int    int `json:"int"`
}

type TestHandler1V2Res struct {
	Int int `json:"int"`
}

type TestHandler1V2Args struct {
	ReqInt        int `json:"req_int"`
	ReturnErrorID int `json:"error_id"`
}

type TestHandler1V3Response struct {
	Int int  `json:"int"`
	B   bool `json:"b,omitempty"`
}

type TestHandler1V3Request struct {
	ReqInt      int                               `json:"req_int"`
	Nested      TestHandler1V3Nested              `json:"nested"`
	Optional    TestHandler1V3Optional            `json:"optional,omitempty"`
	StringMap   map[string]string                 `json:"strings"`
	StringSlice []string                          `json:"slices"`
	ObjMap      map[string]TestHandler1V3Optional `json:"obj_map"`
	ObjSlice    []TestHandler1V3Optional          `json:"obj_slice"`
}

type TestHandler1V3Nested struct {
	ReturnErrorID int `json:"error_id,omitempty"`
}

type TestHandler1V3Optional struct {
	Foo bool `json:"foo"`
}

type httpSessionResponse struct {
	Result string          `json:"result"` //OK or ERROR
	Data   json.RawMessage `json:"data"`
	Error  int             `json:"error"`
}

func (api *Example) set(ctx context.Context, path string, data interface{}, buf interface{}) error {
	apiURL, err := api.balancer.Next()
	if err != nil {
		return err
	}

	b := bytes.NewBuffer(nil)
	encoder := json.NewEncoder(b)
	if err := encoder.Encode(data); err != nil {
		return fmt.Errorf("could not marshal data %+v: %v", data, err)
	}

	r, err := http.NewRequest("POST", createRawURL(apiURL, path, nil), b)
	if err != nil {
		return err
	}

	r.Header.Set("Content-Type", "application/json")
	return do(api.client, r, buf)
}

func createRawURL(url, path string, values url.Values) string {
	var buf bytes.Buffer
	buf.WriteString(strings.TrimRight(url, "/"))
	buf.WriteRune('/')
	buf.WriteString(strings.TrimLeft(path, "/"))
	if len(values) > 0 {
		buf.WriteRune('?')
		buf.WriteString(values.Encode())
	}
	return buf.String()
}

func do(client *http.Client, request *http.Request, buf interface{}) (err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("panic in request %q: %v", request.URL.RequestURI(), r)
		}
	}()

	// Run
	var response *http.Response
	if response, err = client.Do(request); err != nil {
		return err
	}
	defer response.Body.Close()

	// Handle error
	if response.StatusCode != http.StatusOK {
		switch response.StatusCode {
		// TODO separate error types for different status codes (and different callbacks)
		/*
		   case http.StatusForbidden:
		   case http.StatusBadGateway:
		   case http.StatusBadRequest:
		*/
		default:
			return fmt.Errorf("Request %q failed. Server returns status code %d", request.URL.RequestURI(), response.StatusCode)
		}
	}

	// Read response
	var result []byte
	if result, err = ioutil.ReadAll(response.Body); err != nil {
		return err
	}

	var mainResp httpSessionResponse
	if err = json.Unmarshal(result, &mainResp); err != nil {
		return fmt.Errorf("request %q failed to decode response %q: %v", request.URL.RequestURI(), string(result), err)
	}

	if mainResp.Result == "OK" {
		if err = json.Unmarshal(mainResp.Data, buf); err != nil {
			return fmt.Errorf("request %q failed to decode response data %+v: %v", request.URL.RequestURI(), mainResp.Data, err)
		}
		return nil
	}

	// unknown error
//	if mainResp.Error == 0 {
//		return fmt.Errorf("service for request %q returned unknown error code: %v", request.URL.RequestURI(), err)
//	}

	if mainResp.Result != "ERROR" {
		return fmt.Errorf("request %q returned incorrect response %q", request.URL.RequestURI(), string(result))
	}

	return ServiceError{
		Code: mainResp.Error,
		Message: "TODO", // TODO: extract error message from handler info
	}
}

// ServiceError uses to separate critical and non-critical errors which returns in external service response.
// For this type of error we shouldn't use 500 error counter for librato
type ServiceError struct {
	Code    int
	Message string
}

// Error method for implementing common error interface
func (err ServiceError) Error() string {
	return err.Message
}
