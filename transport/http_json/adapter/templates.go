package adapter

var mainTemplate = []byte(`
// It's autogenerated file. It's not recommended to modify it.
package >>>PKG_NAME<<<

import (
    >>>IMPORTS<<<
)

>>>DYNAMIC_LOGIC<<<

>>>STATIC_LOGIC<<<

>>>STRUCTS<<<

`)

var mainImports = []string{
	"bytes",
	"encoding/json",
	"fmt",
	"io/ioutil",
	"net/http",
	"net/url",
	"strings",
	"time",
	"golang.org/x/net/context",
}

var staticLogicTemplate = []byte(`
type httpSessionResponse struct {
	Result string      ` + "`" + `json:"result"` + "`" + `
	Data   json.RawMessage ` + "`" + `json:"data"` + "`" + `
	Error  string      ` + "`" + `json:"error"` + "`" + `
}

type sessionRequest struct {
	URL    string
	Path   string
	Params interface{}
}

type IBalancer interface {
    Next() (string, error)
}

type >>>API_NAME<<< struct {
	client      *http.Client
	serviceName string
	balancer    IBalancer
}

func New>>>API_NAME<<<(balancer IBalancer, apiTimeout time.Duration) *>>>API_NAME<<< {
	return &>>>API_NAME<<<{
		client: &http.Client{
			Transport: &http.Transport{
				//DisableCompression: true,
				MaxIdleConnsPerHost: 20,
			},
			Timeout: apiTimeout,
		},
		serviceName: ">>>API_NAME<<<",
		balancer: balancer,
	}
}

func (api *>>>API_NAME<<<) set(ctx context.Context, path string, data interface{}, buf interface{}) error {
    apiURL, err := api.balancer.Next()
    if err != nil {
        return err
    }
	sessionRequest := &sessionRequest{
	    Path: path,
	    Params: data,
	    URL: apiURL,
    }
	return api.call(ctx, sessionRequest, func(serviceURL string) (interface{}, error) {
		b := bytes.NewBuffer(nil)
		encoder := json.NewEncoder(b)
		if err := encoder.Encode(data); err != nil {
			return nil, fmt.Errorf("could not marshal data %+v: %v", data, err)
		}

		r, err := http.NewRequest("POST", createRawURL(serviceURL, path, nil), b)
		if err != nil {
			return nil, err
		}
		r.Header.Set("Content-Type", "application/json")

		if err := do(api.client, r, buf); err != nil {
			return nil, err
		}
		return buf, nil
	})
}

func (api *>>>API_NAME<<<) call(ctx context.Context, sessionRequest *sessionRequest, caller func(string) (interface{}, error)) (err error) {
    if sessionRequest.URL == "" {
        return fmt.Errorf("Service URL is not defined")
    }

    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic while calling %q service: %v", api.serviceName, r)
        }
    }()

    _, err = caller(sessionRequest.URL)
    return
}

func createRawURL(url, path string, values url.Values) string {
	var buf bytes.Buffer
	buf.WriteString(strings.TrimRight(url, "/"))
	buf.WriteRune('/')
	buf.WriteString(strings.TrimLeft(path, "/"))
	if len(values) > 0 {
		buf.WriteRune('?')
		buf.WriteString(values.Encode())
	}
	return buf.String()
}

func do(client *http.Client, request *http.Request, buf interface{}) (err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("panic in request %q: %v", request.URL.RequestURI(), r)
		}
	}()

	// Run
	var response *http.Response
	if response, err = client.Do(request); err != nil {
		return err
	}
	defer response.Body.Close()

	// Handle error
	if response.StatusCode != http.StatusOK {
	    switch response.StatusCode {
	    // TODO separate error types for different status codes (and different callbacks)
	    /*
        case http.StatusForbidden:
        case http.StatusBadGateway:
        case http.StatusBadRequest:
        */
        default:
            return fmt.Errorf("Request %q failed. Server returns status code %d", request.URL.RequestURI(), response.StatusCode)
        }
	}

	// Read response
	var result []byte
	if result, err = ioutil.ReadAll(response.Body); err != nil {
		return err
	}

    var mainResp httpSessionResponse

    if err = json.Unmarshal(result, &mainResp); err != nil {
        return fmt.Errorf("request %q failed to decode response %q: %v", request.URL.RequestURI(), string(result), err)
    }
    if err = json.Unmarshal(mainResp.Data, buf); err != nil {
        return fmt.Errorf("request %q failed to decode response data %+v: %v", request.URL.RequestURI(), mainResp.Data, err)
    }

	return nil
}
`)

var handlerCallPostFuncTemplate = []byte(`
func (api *>>>API_NAME<<<) >>>HANDLER_NAME<<<(ctx context.Context, data >>>INPUT_TYPE<<<) (>>>RETURNED_TYPE<<<, error) {
    var result >>>RETURNED_TYPE<<<
    err := api.set(ctx, ">>>HANDLER_PATH<<<", data, &result)
	return result, err
}
`)
